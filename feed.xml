<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nicholas Boll</title>
    <atom:link href="http://nicholasboll.github.io/blog/feed.xml" rel="self" type="application/rss+xml"></atom:link>
    <link>http://nicholasboll.github.io/blog</link>
    <description>Experimentations of a Web Developer</description>
    <pubDate>Sat, 08  Aug 2015 15:00:00 -0600</pubDate>
    <generator>Wintersmith - https://github.com/jnordberg/wintersmith</generator>
    <language>en</language>
    <item>
      <title>Angular Component Composition - Part 1 - Introduction</title>
      <link>http://nicholasboll.github.io/blog/articles/angular-component-composition-part-1/</link>
      <pubDate>Sat, 08  Aug 2015 15:00:00 -0600</pubDate>
      <guid isPermaLink="true">http://nicholasboll.github.io/blog/articles/angular-component-composition-part-1/</guid>
      <author></author>
      <description>&lt;h2 id=&quot;components&quot;&gt;Components&lt;/h2&gt;
&lt;p&gt;“Components” is becoming a popular word in web development. The term is vague and generally means small parts. I did a talk recently at a &lt;a href=&quot;http://www.meetup.com/RockyMountainAngularJS/events/223604028/&quot;&gt;local meetup&lt;/a&gt; (video &lt;a href=&quot;https://www.youtube.com/watch?v=BYVesUiUpI4&quot;&gt;here&lt;/a&gt;) about how we at &lt;a href=&quot;https://www.logrhythm.com&quot;&gt;LogRhythm&lt;/a&gt; use Angular to create re-usable components. The definition of components extends to backend infrastructure, middle-layer and UI. This series will be mainly focusing on UI components.&lt;/p&gt;
&lt;h2 id=&quot;composition&quot;&gt;Composition&lt;/h2&gt;
&lt;p&gt;Composition as in &lt;a href=&quot;https://en.wikipedia.org/wiki/Composition_over_inheritance&quot;&gt;composition over inheritance&lt;/a&gt;. AngularJS encourages this with dependency injection of services into controllers, but what is often overlooked as directives provide an excellent way to compose UI components. I don’t mean nesting a component within another component, but truly composing a component directive with other directives. This is what my talk was about and I would like to step through how that is possible and why it is a good idea.&lt;/p&gt;
&lt;h2 id=&quot;how-do-we-do-it-&quot;&gt;How do we do it?&lt;/h2&gt;
&lt;p&gt;I’m going to define a few terms I’ll use over this series: &lt;em&gt;Component&lt;/em&gt;, &lt;em&gt;Decorator&lt;/em&gt; and &lt;em&gt;Component Decorator&lt;/em&gt; (The Angular team changed &lt;em&gt;Decorator&lt;/em&gt; to &lt;em&gt;Directive&lt;/em&gt; to not have a naming collision with &lt;a href=&quot;https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841&quot;&gt;ES2016 Decorators&lt;/a&gt;). The first two are well-defined by the community (I’ve added a few extras). The last is what really adds composition to UI and I make heavy use of.&lt;/p&gt;
&lt;h4 id=&quot;component&quot;&gt;Component&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Element selector&lt;/li&gt;
&lt;li&gt;Isolate scope&lt;/li&gt;
&lt;li&gt;Has a template&lt;/li&gt;
&lt;li&gt;Has a controller&lt;/li&gt;
&lt;li&gt;Has a model&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;decorator&quot;&gt;Decorator&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Attribute selector&lt;/li&gt;
&lt;li&gt;Does not have a template&lt;/li&gt;
&lt;li&gt;Has a controller&lt;/li&gt;
&lt;li&gt;Has a model&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;component-decorator&quot;&gt;Component Decorator&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Attribute selector&lt;/li&gt;
&lt;li&gt;Does not have a template&lt;/li&gt;
&lt;li&gt;Requires a Component or Directive&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;First, we need to make a component and make sure it has a controller. Actually, for my first example I’m going to make a &lt;em&gt;Decorator&lt;/em&gt;, but it acts like a &lt;em&gt;Component&lt;/em&gt;. The component should be as minimalistic as possible. This allows for maximum composition with &lt;em&gt;Component Decorators&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;tooltip-decorator&quot;&gt;Tooltip Decorator&lt;/h2&gt;
&lt;iframe src=&quot;http://embed.plnkr.co/uCQtLoBqcLbFhvRFG0so/preview&quot; width=&quot;100%&quot; height=&quot;300px&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;Usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;span&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;tooltip&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;tooltip-message&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;'Hello World!'&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Hover over me!&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Controller:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TooltipController&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{

  &lt;span class=&quot;comment&quot;&gt;// API for state&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.model = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TooltipModel({});
}

TooltipController.prototype.show = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;showTooltip&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.model.shouldShow) {
    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.model.isShowing = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;
  }
};

TooltipController.prototype.hide = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hideTooltip&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.model.isShowing = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;
}
app.controller(&lt;span class=&quot;string&quot;&gt;'TooltipController'&lt;/span&gt;, TooltipController);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Model:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TooltipModel&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(config)&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;comment&quot;&gt;// Boolean - if the tooltip should be shown - component decorators can modify this property.&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.shouldShow = config.shouldShow || &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;

  &lt;span class=&quot;comment&quot;&gt;// Boolean - if the tooltip is currently being shown. Component decorators can use this property to test if the tooltip is being shown&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.isShowing = config.isShowing || &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;

  &lt;span class=&quot;comment&quot;&gt;// String - the message the tooltip contains. It is an angular expression&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.message = config.message || &lt;span class=&quot;string&quot;&gt;''&lt;/span&gt;;

  &lt;span class=&quot;comment&quot;&gt;// Number - the x coordinate of the tooltip&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = config.x || &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;

  &lt;span class=&quot;comment&quot;&gt;// Number - the y coordinate of the tooltip&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.y = config.y || &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tooltip&lt;/code&gt; Decorator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;app.directive(&lt;span class=&quot;string&quot;&gt;'tooltip'&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;($compile)&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; {
    restrict: &lt;span class=&quot;string&quot;&gt;'A'&lt;/span&gt;,
    controller: &lt;span class=&quot;string&quot;&gt;'TooltipController'&lt;/span&gt;,
    &lt;span class=&quot;comment&quot;&gt;// controllerAs: 'tooltip', // we won't use this since we are kind of stepping outside normal angular stuff&lt;/span&gt;

    link: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tooltipLink&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($scope, $element, $attrs, TooltipController)&lt;/span&gt; &lt;/span&gt;{
      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; $body = angular.element(&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.body);
      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; $tooltipElement;
      &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; tooltipScope = $scope.$&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// new isolate scope&lt;/span&gt;
      tooltipScope.tooltip = TooltipController; &lt;span class=&quot;comment&quot;&gt;// controllerAs in the isolate scope&lt;/span&gt;

      &lt;span class=&quot;comment&quot;&gt;// events&lt;/span&gt;
      $element.on(&lt;span class=&quot;string&quot;&gt;'mouseover'&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onMouseover&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(event)&lt;/span&gt; &lt;/span&gt;{
        TooltipController.setPosition(event.clientX + &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, event.clientY + &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);
        TooltipController.show();
        tooltipScope.$digest(); &lt;span class=&quot;comment&quot;&gt;// let Angular know something interesting happened - local digest for performance&lt;/span&gt;
      });

      $element.on(&lt;span class=&quot;string&quot;&gt;'mouseout'&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onMouseout&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(event)&lt;/span&gt; &lt;/span&gt;{
        TooltipController.hide();
        tooltipScope.$digest(); &lt;span class=&quot;comment&quot;&gt;// let Angular know something interesting happened - local digest for performance&lt;/span&gt;
      });

      &lt;span class=&quot;comment&quot;&gt;// react to state changes&lt;/span&gt;
      tooltipScope.$watch(&lt;span class=&quot;string&quot;&gt;'tooltip.model.isShowing'&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(isShowing)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isShowing) {
          &lt;span class=&quot;comment&quot;&gt;// lazy initialization of tooltip contents&lt;/span&gt;
          &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!$tooltipElement) {
            $tooltipElement = $compile(&lt;span class=&quot;string&quot;&gt;'&amp;lt;div class=&quot;tooltip&quot;&amp;gt;{{tooltip.model.message}}&amp;lt;/div&amp;gt;'&lt;/span&gt;)(tooltipScope);
          }
          $tooltipElement.css({
            top: TooltipController.model.y + &lt;span class=&quot;string&quot;&gt;'px'&lt;/span&gt;,
            left: TooltipController.model.x + &lt;span class=&quot;string&quot;&gt;'px'&lt;/span&gt;
          });
          $body.append($tooltipElement);
        } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
          $tooltipElement &amp;amp;&amp;amp; $tooltipElement.remove();
        }
      });
    }
  };
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tooltip-messsage&lt;/code&gt; Component Decorator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;app.directive(&lt;span class=&quot;string&quot;&gt;'tooltipMessage'&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; {
    restrict: &lt;span class=&quot;string&quot;&gt;'A'&lt;/span&gt;,
    &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;'tooltip'&lt;/span&gt;,

    link: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tooltipMessageLink&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($scope, $element, $attrs, TooltipController)&lt;/span&gt; &lt;/span&gt;{
      $scope.$watch($attrs.tooltipMessage, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(message)&lt;/span&gt; &lt;/span&gt;{
        TooltipController.model.message = message;
      });
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;why-a-controller-&quot;&gt;Why a controller?&lt;/h4&gt;
&lt;p&gt;The controller of a component becomes the API for other component decorators. When a component decorator requires the component, it will gain access to the instance of that components controller. This is a very powerful concept for composition of components. Decorator components should interact directly with the controller and model.&lt;/p&gt;
&lt;h4 id=&quot;why-a-model-&quot;&gt;Why a model?&lt;/h4&gt;
&lt;p&gt;All components should have a strongly typed model - it becomes the state API for other component decorators and the application. The model should only contain state and no logic.&lt;/p&gt;
&lt;h4 id=&quot;why-a-big-link-function-&quot;&gt;Why a big link function?&lt;/h4&gt;
&lt;p&gt;The link function should be where events are attached and model watches happen. This allows the controller to be unit tested without DOM. In our project, all controllers and services are unit tested. Component link functions are not unit tested, but rather integration tested through &lt;a href=&quot;https://angular.github.io/protractor/&quot;&gt;Protractor&lt;/a&gt;. We do integration testing of components because of the complex differences between browsers.&lt;/p&gt;
&lt;h4 id=&quot;component&quot;&gt;Component&lt;/h4&gt;
&lt;p&gt;The the component should interact with the controller and model. It should observe the model state and react to changes rather than directly respond to user events. This separation allows component decorators to call controller methods and the component will just react to state changes and makes controllers easier to test in isolation (without a DOM).&lt;/p&gt;
&lt;h4 id=&quot;why-is-tooltip-message-a-directive-&quot;&gt;Why is &lt;code&gt;tooltip-message&lt;/code&gt; a directive?&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;tooltip-message&lt;/code&gt; is a &lt;em&gt;Component Decorator&lt;/em&gt;. Notice how it requires the &lt;code&gt;tooltip&lt;/code&gt; &lt;em&gt;Decorator&lt;/em&gt; and gets the instance of its controller. It sets up a one-way (&lt;strong&gt;Note&lt;/strong&gt;: NOT two-way) binding that updates the component’s model. This pattern allows the component to just worry about displaying model state with component decorators effecting that state in interesting ways.&lt;/p&gt;
&lt;h4 id=&quot;-tooltip-overflow-component-decorator-&quot;&gt;&lt;code&gt;tooltip-overflow&lt;/code&gt; Component Decorator:&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;lang-html&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;style&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;max-width: 100px;&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;tooltip&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;tooltip-message&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;longtext&quot;&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;tooltip-overflow&lt;/span&gt;&amp;gt;&lt;/span&gt;{{longtext}}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;lang-javascript&quot;&gt;app.directive(&lt;span class=&quot;string&quot;&gt;'tooltipOverflow'&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; {
    restrict: &lt;span class=&quot;string&quot;&gt;'A'&lt;/span&gt;,
    &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;'tooltip'&lt;/span&gt;,

    link: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tooltipOverflowLink&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;($scope, $element, $attrs, TooltipController)&lt;/span&gt; &lt;/span&gt;{
      $element.on(&lt;span class=&quot;string&quot;&gt;'mouseover'&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(event)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ($element[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].scrollWidth &amp;gt; $element[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].clientWidth) {
          TooltipController.model.shouldShow = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;
        } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; {
          TooltipController.model.shouldShow = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;
        }
      });
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now things get interesting. We can conditionally show a tooltip. In this case, when the user moves the mouse over the tooltip target, the width is evaluated to see if an ellipsis is present. If an ellipsis is present, the tooltip will display, otherwise it will not. Try changing the tooltip value in the input in the provided example. For efficiently, the value is evaluated when the user mouses over and not when the tooltip value changes. This keeps watches light (NEVER do DOM measurement inside a &lt;code&gt;$watch&lt;/code&gt; - it will really hurt the performance of the application).&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The whole idea of composition is to have a small base component with decorators that modify the behavior. These decorators should be small and only do one thing. This is a difficult balance, but keeps additional features to be additional decorators rather than modification of the root component. The alternative is a very large component with a growing number of config flags. We use this composition model to separate our component UI from our application (different code repositories). Usually application component decorators interact with the component API to give the component data. This way we can completely test all expected behaviors of components void of any application dependencies.&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>